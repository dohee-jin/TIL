## TIL - 2025.08.25

### 🔍 오늘 배운 내용
- 리액트 초기 설정 및 기초(컴포넌트) 작성
- props
- 이벤트 바인딩
- 상태값 처리(useState Hook)

---

#### 리액트(React)란?
> 바닐라 js만으로는 관리하기 힘든 복잡한 ui와 동적인 변화를 더 효과적으로 관리하기 위해서 탄생함 

- 컴포넌트 기반 개발 방식과 virtual dom 을 통해 데이터 변경 시 필요한 부분만 갱신하여   
애플리케이션의 성능이 향상되었다.   
 - 또한 페이스북 뉴스피드, 인스타그램과 같은 서비스에서 볼 수 있는 무한 스크롤 ui에서도   
부드러운 랜더링을 지원하여 ux 개선에도 크게 기여했다.   
- 컴포넌트 기반의 아키텍쳐를 도입하여 재사용성을 높이고 유지보수를 쉽게 할 수 있게 만들었다.
- 선언적 접근 방식을 지원하여 바닐라 js에서는 개발자가 일일이 DOM 조작 코드를 작성해야 했던 것과 달리 리액트에서는 무엇을 보여주고 싶은지 선언하면 리액트가 알아서 상태에 맞게 ui를 그려준다.

기존 바닐라 코드 예시
```
    if (!userNav && isLoggedIn) {
        userNav = document.createElement('div');
        userNav.className = 'user-nav';
        userNav.style.cssText = 'display: flex; align-items: center; gap: 15px; margin-left: auto;';

        // 적절한 위치에 삽입 (기존 버튼들 근처)
        const nav = document.querySelector('nav') || document.querySelector('header') || document.body;
        if (loginBtn && loginBtn.parentNode) {
            loginBtn.parentNode.insertBefore(userNav, loginBtn);
        } else {
            nav.appendChild(userNav);
        }
    }
```
리액트 코드 예시
```
return (
        <div className='expense-item'>
            <ExpenseDate date={date} />
            <div className='expense-item__description'>
                <h2>{title}</h2>
                <div className='expense-item__price'>{formatPrice}원</div>
            </div>
            {/*<button id='btn1' onClick = {clickHandler}>버튼1</button>*/}
        </div>
    );
```
---

#### 리액트 초기 설정 및 기초(컴포넌트) 작성

1. 리액트 실행
    - node.js 설치
    - npm create vite@latest 프로젝트폴더명   
        proceed(y) -> React -> Javascript 선택   
        vite: build.gradle과 같은 빌드 도구의 역할을 함
    -  cd 프로젝트폴더명 -> npm install -> npm run dev

2. 리액트 폴더 구조
```
react-study/
|_  node_modules/
|_ public/
|_  src/
|   |_  components/
|      |_  App.jsx
|      |_  main.jsx
|_  .gitignore
|_  eslint.config.js        # 문법 검사
|_ index.html
|_  package.json            # build gradle과 같은 역할
|_  package-lock.json
|_  README.md
|_  vite.config.js          # 빌드 설정
```
package.json에 새로운 라이브러리 버전을 명시해서 작성하고 난 뒤   
npm 명령어를 통해 라이브러리를 설치한다.   
설치한 라이브러리는 node_modules 에 저장된다.   

초기 폴더에서 index.css, App.css, asset 폴더 삭제   

App.js 을 아래와 같이 초기화 시킨다.
```
function App() {
    return (

    );
}

export default App
```
컴포넌트는 각 기능별로 쪼개서 작성하고   
컴포넌트 파일명과 동일하게 css 파일도 작성한다.   
태그는 return에 작성한다.   
변수값이나 함수 값은 {} 중괄호 안에 작성한다.
```
const Expense = () => {

    return (
        <div className='{}' onClick={}><div> 
        // class -> className 
        // 위의 코드는 html이 아니기 때문에 react 사용법에 맞게 사용해야 한다.
    );
}
export defualt Expense;
```
작성한 컴포넌트들은 App.jsx에서 합쳐서 사용한다.
```
function App() {
    return (
        <Expense />
    );
}

export default App
```
jsx는 리턴되는 데이터가 반드시 하나여야 한다.   
여러 컴포넌트를 리턴하기 위해서는 빈 <></> 프레그먼트 안에   
컴포넌트를 작성하면 된다.
```
return (
    <>
        <Expense />
        <Expense />
    </>
)
```

---

#### props
컴포넌트간 데이터를 전달하는 메커니즘을 제공한다.   
단방향으로 (부모 -> 자식 컴포넌트) 데이터를 전달한다.   
javascript의 모든 속성을 전달할 수 있다.  
{} 중괄호 안에 전달하고자 하는 속성을 작성하는데   
문자열의 경우 {} 대신 '' 안에 넣어서 작성한다. 
```
const App = () => {
    return ( 
        <>
            <Expense title='닭강정' />
        </>
    )
}

// props 는 객체로 넘어옴
const Expense = (props) => {
    return (
        <div className="Expense">
            <h1>{props.title}</h1>
        </div>
    )
}

// 구조분해할당해서 사용
const Expense = ({title}) => {
    return (
        <div className="Expense">
            <h1>{title}</h1>
        </div>
    )
}
```
태그를 가변적으로 처리할 때 props children을 사용한다.   
```
// 태그를 감쌀 공통 태그
const Wrapper = ({children, className = ''}) => {
    // console.log(`props:`, props);
    return (
        <div className = {`${className}`}>
            {children}
        </div>
    );
};

// children을 전달하는 태그
const App = () => {
    return (
        <>
            <Wrapper className = 'card'> // className 도 className에 전달됨
                <Expense /> // Expense 컴포넌트가 children으로 전달됨
                <h1></h1> // h1이 children으로 전달됨
            </Wrapper>
        </>
    ); 
}

```

---

#### 이벤트 바인딩   
리액트 이벤트 바인딩은 addEventListener('', e => {})를 사용하지 않는다.   
대신 onClick={}, on...={} 등으로 이벤트 바인딩을 한다.   
{} 안에는 바로 함수를 작성할 수 있고 {() => {}},
따로 함수를 작성하여 {eventHandler} 함수를 호출하여 사용할 수도 있다.   
```
const Counter = () => {

    let count = 10;

    const increaseHandler = () => ++count;

    return (
        <div>
            <h1>숫자: {count}</h1>
            <button onClick={increaseHandler}>증가</button>
            <button onClick={() => --count;}>감소</button>
        </div>
    );
};
```
이렇게 하면 이벤트 바인딩을 할 수 있지만 count에는 숫자의 변경을 확인할 수 없다.   
숫자의 변경을 확인하기 위해서는 useState를 사용하여 상태값을 관리해야한다.

---

#### 상태값 관리(useState Hook)   
리액트는 virtual dom 이라는 개념을 도입하여 애플리케이션의 상태가 변경될 때마다   
가상 돔으로 전체 ui 랜더링을 하여 기존 ui와 비교하여(스냅샷 비교) 변경된 부분을 확인하고   
변경된 부분만 실제 DOM에 반영하여 효율적으로 화면 랜더링을 진행한다.   
```
import React, {useState} from 'react';

const Counter = () => {
    // [0: 초기값 , 1: setter] = useState(초기값)
    // useState에 들어가는 초기값에 의해 useState[0] 의 타입이 결정된다.
    const [count, setCount] = useState(10)

    const increaseHandler = () => {
        console.log(`count: ${count}`);
        return setCount(count + 1);
    };
    const decreaseHandler = () => setCount(count - 1);

    return (
        <div>
            <h1>숫자: {count}</h1>
            <button onClick={increaseHandler}>증가</button>
            <button onClick={decreaseHandler}>감소</button>
        </div>
    );
};
```

---

### 🛠️ 문제와 해결
- 문제: 생성한 react-study 폴더를 깃에 올릴 때 
- 해결: 

---

### 🤔 내일 할 일 / 복습할 것
- 리액트 공부
- 북적북적 프로젝트 일일회고, 전체회고 작성