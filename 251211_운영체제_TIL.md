## TIL - 2025.12.11

### 🔍 오늘 배운 내용

#### 운영체제 시험 준비(데드락)


#### 데드락

데드락이란?   

두개 이상의 작업(프로세스, 스레드, 트랜잭션 등)이 서로 상대방이 가진 자원을 가디리며 아무것도 진행하지 못하고 무한정 대기하는 상태를 의미한다.   

시스템 자원을 공유하는 과정에서 자원을 독점한 상태로 다른 프로세스가 점유한 자원을 기다리는 상황이 반복될 때 발생한다.   

---

#### 데드락 발생조건   

데드락은 다음의 4가지 발생조건을 만족해야 발생한다.   
1. 상호배제(mutal exclusion)
2. 점유 대기(Hold and Wait): 하나의 자원을 점유하고 있는 프로세스가 추가 자원을 기다리는 상태
3. 비선점(Non-preemptible): 할당된 자원은 사용을 완료하기 전에는 강제로 회수 할 수 없다.
4. 순환대기(Circular wait): 프로세스와 자원들이 원(체인)을 구성하며 상호요청하는 경우   

4가지 필요조건 중 하나라도 깨질 수 있으면 데드락이 발생하지 않는다.   
4가지 조건이 모두 성립할 때에만 데드락이 발생할 수 있다.  

---

#### 데드락 vs 기아(starvation)상태   

데드락은 프로세스가 서로 각자 자원을 선점하고 버티는 상태로 다 같이 멈추는 상태고 기아 상태는 특정 프로세스만 계속 자원할당을 받지 못하는 상태다.   

---

#### 데드락 발생 해결방법   

1. Deadlock Prevention(방지)
2. Deadlock Avoidance(회피)
3. Deadlock Detection / Recovery(탐지/복구)   

Deadlock Prevention   
데드락 발생 조건 자체를 깨버리는 방법으로 4가지 필요조건 중 최소 한개를 아예 성립 못하게 해서 데드락이 아에 발생하지 않도록 한다.  

- 상호배제(mutal exclusion)   
이론적으로는 가능하나, 현실적으로 깨기 힘들다.   
프린터, 락, 세마포어와 같은 한 번에 한 프로세스만 사용해야하는, 공유 불가능한 자원은 반드시 상호 배제적으로 접근해야 한다. 상호배제를 부정하면 임계 영역에 동시에 프로세스가 접근할 수 있게 된다.

- 점유대기(hold & wait)
프로세스가 실행할 때 필요한 자원을 한꺼번에 할당받고 작업을 시작할 수 있게 하고
자원을 할당 받은 상태에서는 새 자원 요청을 금지한다.   

    * **장점**: 점유 대기로 인해 발생하는 데드락을 원천 차단한다.   
    * **단점**:    
        * 우선 순위가 낮은 프로세스는 기아 상태에 빠질 수 있다.
        * 프로세스가 나중에 사용할 자원도 실행 시 함께 할당 받아 자원 이용률이 저하된다.
        * 프로세스가 수행 되기 이전에 필요한 자원 전체를 알아야 한다.   

- 비선점(Non-preemption)
어떤 프로세스에게 할당된 자원은 해당 프로세스가 스스로 반납하기 전까지는 강제로 자원을 뺏을 수 없지만 필요한 상황이 발생하면 강제로 자원을 회수한다.   

    * *첫번째**: 몇 가지 자원을 점유 중인 프로세스가 즉각적으로 할당 될 수 없는 다른 자원을 요청하면 현재 점유하고 있는 모든 자원들을 강제 회수한다. (hold & wait 상태가 되지 않도록 한다)   
    * **두번째**: 프로세스(Pi)가 요청한 자원을 가지고 있는 다른 프로세스(Pj)도 다른 자원 할당을 대기하고 있는 상태이면(block 상태) Pj의 자원을 강제 회수하여 Pi에게 할당하거나 자원의 상태를 사용가능 상태로 변경한다.

- 순환대기(circular wait)
모든 자원에 대해 할당 순서를 부여하고 프로세스는 순서(순서는 증가하는 방향으로)에 따라 자원을 요청하게 한다.   

    * **규칙1**: 자원에 할당한 번호가 증가하는 방향으로만 자원을 부여
    * **규칙2**: 번호가 작은 자원을 새로요청하는 경우 자신(프로세스)이 점유하고 있는 자원들 중 새로 요청하는 자원보다 번호가 큰 자원들은 반납해야한다.

---

Deadlock Avoidance   
데드락 회피는 시스템이 항상 safe 상태에 머물도록 각 자원 요청이 들어올 때마다 요청을 허용해도 나중에 모든 프로세스가 정상 종료될 수 있는지를 판단하여 안전하면 요청을 허용하고 안전하지 않으면 요청을 거절하는 방식이다.   

대표적인 방법으로 다익스타리의 은행원 알고리즘(Banker's Algorithm)을 사용한다.

- safe state   
어떤 순서(p1, p2, p3 ...pn)로 프로세스에 자원을 할당할 때 모든 프로세스가 언젠가는 반드시 종료되는 상태를 safe state라고 하며 프로세스의 순서를 safe sequence라고 한다.   

- unsafe state   
어떤 순서로 해도 모든 프로세스를 종료할 안전한 순서를 찾을 수 없는 상태를 의미한다. 데드락이 발생한 상태는 아니며 데드락으로 갈 수 있는 안전하지 않은 상태를 의미한다.

> safe state는 데드락 상태가 아니며 데드락 상태는 unsafte state 이다. 하지만
unsafe state는 모두 데드락 상태가 아니다.

**Banker's Algorithm**   
- Max[n][m]: 각 프로세스가 최대로 필요로 하는 자원의 수
- Allocation[n][m]: 이미 할당되어있는 자원의 수
- Need[n][m]: Max - Allocation, 앞으로 더 필요한 자원의 수
- Available[n]: 시스템 안에 남은 자원의 수

safe algorithm: safe 상태 검사 또는 안전성 검사를 진행하여 프로세스가 safe state 인지 unsafe state인지 판단한다.  

1. 초기화   
    * work = Available  
    * 모든 프로세스에 대해 Finish[i] = false 

2. 끝낼 수 있는 프로세스 찾기
    * 아직 Finish[i] = false인 프로세스 중에서 Nedd[i] <= work를 만족하는 프로세스를 하나 찾는다.
    * 남은 자원만으로 이 프로세스는 실행 후 종료가 가능하다.
    * 만족하는 경우를 찾지 못한 경우 4번으로 이동한다.

3. 종료된 프로세스의 자원 돌려주기..?
    * work = work + Allocation[i] 
    * Finish[i] = true

4. 조건을 만족하는 프로세스를 찾지 못 했을 때
    * 어떤 i에 대해서도 Need <= work(2번단계) 조건을 만족하는 프로세스가 없는데 finish가 false 상태인 프로세스가 있으면 --> unsafe state로 판단
    * 모든 프로세스의 Finish[i] = true 가 되면 --> safe sate, 이 때 순서를 safe sequence라고 한다.

Request Algorithm: 어떤 프로세스가 자원을 요청했을 때 허용 여부를 판단한다.  

1. 기본 조건 체크   
    * request[k] <= Need[K]   
    최대 필요량 보다 더 요구하는 경우 잘못된 요청으로 판단하여 자원 할당을 거절한다.   
    * request[k] <= Available   
    지금 시스템에 남아있는 자원으로 줄 수 있는 요청을 판단하여 자원이 부족한 경우 대기한다.

2. 가상 할당..? 기본 조건 체크를 통과한 경우 가상 할당하여 상태를 변경해본다.
    * Available = Available - request[k]
    * Allocation[k] = Allocation[k] + request[k]
    * Need[k] = Need[k] - request[k]

3. safe algorithm 실행
    * 할당된 상태에서 safe algorithm을 실행했을때 safe sequence가 존재하면  safe state로 판단하여 실제 할당을 진행한다.
    * safe sequence가 없는 경우 unsafe state로 판단하여 요청을 거절하고 상태를 원상복구 한다. 

---

Deadlock Detection / Recovery   
데드락을 막지 않고 발생할 수 있게 두되 주기적으로 탐지 알고리즘을 돌려서 데드락을 찾은 후 복구하는 방식이다.   

1. Detection(탐지)   
* single instance 자원일 때: 
    * wait-for graph를 사용한다. 
    * 하나의 리소스에 대해서만 대응할 수 있다.
    * 프로세스 노드의 그래프에서 사이클을을 탐지하여 사이클이 존재한다면 데드락 발생을 탐지한다.   

* multi instance 자원일 때:
    * 은행가 알고리즘과 비슷하게 동작한다.
    * Available, Allocation, Request 활용
    * 더 이상 할당 가능한 자원이 없는데 끝나지 않은 프로세스가 있다면 데드락 발생을 탐지

2. 복구(Recovery)
    * 프로세스 강제 종료(Abort)
        * 데드락 관련 모든 프로세스를 한 번에 다 강제 종료 시킨다.
        * 한 개씩 골라서 사이클이 없어질 때까지 반복한다.

    * 리소스 강제 회수(resource preemption)
        * 데드락에 걸린 프로세스 들 중 일부의 자원을 빼앗아 다른 프로세스에게 재할당해서 사이클을 끊는다.   

        리소스 강제 회수에는 세가지 문제점이 발생하는데
        1. 희생 프로세스 선택(victim): 최소비용 문제
        2. 데드락 이전 상태로 돌아가기(rollback)
            * 전체 시스템 롤백
            * 데드락 관련 프로세스만 롤백
        3. 기아 상태 발생 가능(starvation)   

        항상 같은 프로세스만 희생양으로 뽑히면 해당 프로세스는 계속 리소스를 뺏기고 롤백 당해서 영원히 작업을 끝내지 못하는 기아 상황에 놓인다.   

        해결방법은 프로세스마다 victim으로 선택된 횟수를 기록해 둔다





