## TIL - 2025.08.26

### 🔍 오늘 배운 내용
- 객체로 상태값 관리하기
- 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하기
- 동적 / 조건부 렌더링

---

#### 객체로 상태값 관리하기
- 단일값 상태: 상태의 각 부분을 독립적으로 관리하는 방식. 간단하고 직관적이며, 각 상태를 독립적으로 업데이트 할 수 있다
```
const [title, setTitle] = useState('');
const [price, setPrice] = useState(0);
const [date, setDate] = useState(null);
```
- 객체 상태: 여러 상태를 하나로 묶어 관리하는 방식. 여러 상태를 그룹화하고 한 번에 여러 상태를 업데이트 할 수 있다.
```
// 변수로 분리해서 관리
const initUserInputState = {
    title: '',
    price: 0,
    date: null
};

const [userInput, setUserInput] = useState(initUserInputState);
```
title, price, date의 상태를 변경할 때 setUserInput(userInput) 으로 변경하게되면 **상태 업데이트의 불변성**을 위반하여 문제가 발생한다.   

상태 업데이트의 불변성 문제 발생 코드
```
userInput.title = e.target.value;
setUserInput(userInput)
``` 

리액트는 기존객체에서 프로퍼티 값만 바꾸면 상태변경을 감지하지 못한다.   
기존 객체를 그대로 참조해서 setState를 하게 되면 리액트는 주소가 같기 때문에 상태 변화를 감지하지 못한다.   

-> 새 객체를 만들어서 새 객체로 상태를 변경한다.
```
const newUserInput = {
    title: e.target.value,
    price: 0,
    date: null
}
```
각 입력창마다 핸들러를 만들고 위의 코드처럼 새 객체를 setState 하면 다른 입력창들의 값이 초기화 되는 문제가 발생한다.   
```
setUserIput({
    ...userInput // 스프레드로 기존 userInput의 값을 복사해온다.
    // 같은 키가 있으면 나중에 선언된 값이 앞의 값을 덮어씀.
    title: e.target.value 
})
```
주의할 점은 리액트의 상태 업데이트는 비동기적으로 동작하기 때문에 콜백 함수를 사용하여 동시성 문제를 해결해야 한다.   
콜백 함수의 파라미터에는 이전 값을 넣어준다.
```
setUserInput((prev) => {
    ...prev,
    title: e.target.value
})
```

---

#### 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하기   
자식 컴포넌트에서 부모 컴포넌트로 데이터 전달하는 방법이다.   
부모 컴포넌트에서 props를 통해 함수를 자식 컴포넌트로 내려보낸다.
```
const onAddNewGoal = (goal) => {
        console.log(goal);
        setGoals(prev => [...prev, goal])
}

return (
   <CourseInput onSave={onAddNewGoal} /> 
)
```
자식 컴포넌트에서는 props로 함수를 받고 함수의 호출 인수로 데이터를 부모 컴포넌트로 전달한다.   
```
const CourseInput = ({ onSave }) => {
    // 이벤트 동작시 부모 컴포넌트가 보낸 함수를 실행한다
   const addGoalSubmit = e => {
        e.preventDefault();

        // 부모 컴포넌트로 goal 전달
        onSave(goal); 

        // 입력창 초기화
        setGoal(initGoal)
    } 
}
```
부모 컴포넌트는 자식 컴포넌트로 부터 받은 파라미터 값을 꺼내서 사용한다.
```
const onAddNewGoal = (goal) => {
    console.log(goal);
    setGoals(prev => [...prev, goal])
}
```
자식 컴포넌트로 부터 부모 컴포넌트에 데이터를 전달하기 위해서 중간에 위치한 컴포넌트에게 불필요한 props 들이 전달되는 현상이 발생한다.   
이 현상을 props drilling 이라고 부르며 상태관리 api, 라이브러리를 활용하여 관리한다.

---

#### 동적 / 조건부 렌더링
렌더링 할 요소들을 배열에 매핑하고 map, filter를 사용하여 조건별로 동적 렌더링을 한다.   
```
const CourseList = ({goals}) => {
    const content = goals.map(goal =>
        <CourseItem id={goal.id} text={goal.text}/>)
}
```

동적 렌더링에서 각 항목이 다른 항목과 구별되도록 **key prop**을 사용한다.   
key prop을 활용하면 리액트가 컴포넌트와 dom 요소를 효율적으로 렌더링을 할 수 있다.   
```
const CourseList = ({goals}) => {
    const content = goals.map(goal =>
        <CourseItem key={goal.id} id={goal.id} text={goal.text}/>)
}
```
자식 컴포넌트에서는 key 값에 접근할 수 없어서 id 를 따로 추가해주었다.   

조건부 렌더링을 위해서 별도의 변수를 하나 생성해주고   
if 조건이나 filter 를 활용하여 조건별로 필터링을 진행하고 변수에 저장한다.
```
const[toggle, setToggle] = useState(false)

const formComponent = <ExpenseForm onSave={onSave} onCancel={() => setToggle(false)}/>
const buttonComponent = <button onClick={() => setToggle(true)}>새로운 지출 추가하기</button>

```
return에는 중괄호로 조건부로 렌더링 될 변수를 넣는다.
```
return (
    <ul className='goal-list'>
        { toggle ? formComponent : buttonComponent }
    </ul>
);
```
해당 코드는 불리언 타입의 toggle 변수로 true, false 값에 따라 formComponent와 buttonComponent 조건부로 렌더링을 진행한다.

---

### 🚨 트러블슈팅
#### 🛠️ 문제와 원인
- 문제: 렌더링 무한 루프(Uncaught Error: Too many re-renders. React limits the number of renders to prevent an infinite loop.)
- 원인: setToggle() 를 함수로 전달해야되는데 직접 호출해서 문제 발생   
**() => {setToggle()}** 화살표 함수로 setToggle(false) 함수 자제를 전달하여 이벤트가 발생할 때마다 실행된다. 에러가 난 코드는 컴포넌트가 렌더링 될 때마다 함수가 실행되어 무한루프가 발생하고 있다.

#### ✅ 해결 방법
콜백으로 setToggle() 함수를 전달하도록 수정했다.
```
// 직접 setToggle 함수를 호출
const formComponent = <ExpenseForm onSave={onSave} onCancel={setToggle(false)}/>

// 콜백으로 함수 전달 
const formComponent = <ExpenseForm onSave={onSave} onCancel={() => setToggle(false)}/>
```

---

#### 🛠️ 문제와 원인
- 문제: CourseGoal 연습문제 중 setGoal 호출 후 console.log(goals)로 출력하면 업데이트된 값이 아닌 이전 값이 출력된다.
- 원인: 리액트의 상태 업데이트는 비동기적으로 처리되며 setState 호출 즉시 상태가 변경되지 않고 다음 렌더링 사이클에서 반영된다.

#### ✅ 해결 방법
상태 자체는 정상적으로 업데이트되고 있으며, 단순히 콘솔 출력 타이밍의 문제였다. 코드 수정이 필요한 상황이 아니었다.

---

#### 🛠️ 문제와 원인
- 문제: 배열에서 특정 요소를 삭제하려고 pop()을 사용했지만 원하던 요소가 아닌 배열 맨 끝 요소가 삭제된다.
- 원인: pop()은 배열의 마지막 요소만 제거하는 메서드로, 특정 조건이나 위치의 요소 삭제에는 사용할 수 없다.
```
 const onCancelGoal = (id) => {
        for(const goal of goals) {
            if(goal.id === id) {
                goals.pop(id);
                break;
            }
        }
        const newGoals = [...goals];

        setGoals(() => [...newGoals])
    }
```

#### ✅ 해결 방법
splice를 사용하여 문제를 해결하려 했지만 원하는 요소가 삭제되지 않는 문제가 다시 발생했다.   
goals는 상태변수로 관리되는 배열인데 바로 goals에서 변경을 하려니까 제대로 렌더링 되지 않았고,   
splice 에도 인덱스 값을 넣지 않아서 제대로 삭제 동작이 실행되지 않았다.
```
const onCancelGoal = (id) => {
    for(const goal of goals) {
        if(goal.id === id) {
            goals.splice(id, 1);
            break;
        }
    }
    const newGoals = [...goals];

    setGoals(() => [...newGoals])
}
``` 
newGoals의 위치를 변경하고,  
```
const onCancelGoal = (id) => {
    const newGoals = [...goals];
    let index = -1;
    for (let i = 0; i < newGoals.length; i++) {
      if (newGoals[i].id === id) {
        index = i;
        break;
      }
    }
    
    if (index !== -1) {
      newGoals.splice(index, 1);
      setGoals(newGoals);
    }
}
``` 
위의 코드로 수정하여 원하는 동작이 실행됨을 확인했다.   
현재 코드보다 더 좋은 방법을 찾아보던 중 filter를 사용하여 제거하는 방법을 추천받았다. 
```
setGoals(prev => prev.filter(goal => goal.id !== id))
```
filter(), map() 등 배열고차함수를 활용하면 상태변경 시 원본을 변경하지 않고 새로운 배열, 객체를 생성하여 리액트의 불변성 원칙을 지키고 조건부 렌더링을 할 수 있다는 것을 알게되었다.

#### 💡 추가로 알게 된 내용
- 메모리 관리: 새 객체로 상태 변경을 진행하면 기존 객체는 메모리에 그대로 남아있다가,   
더 이상 참조되지 않으면 자바스트립트 가비지 컬렉터가 자동으로 메모리에서 정리한다.

