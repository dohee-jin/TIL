## TIL - 2025.08.27

### 🔍 오늘 배운 내용
- 동적 스타일링
- 모듈 css
- 연습문제: 투두리스트 만들기

---

#### 동적 스타일링   
동적, 조건부 렌더링과 마찬가지로 스타일링도 동적으로 반영할 수 있다.  
isValid 값에 따라 invalid 클래스가 동적으로 삽입되고 있다. 
```
<div className={`form-control ${isValid === false ? 'invalid' : ''}`}>
```
인라인으로도 스타일을 추가 할 수 있다. 
```
style={{color: 'red'}}
```

---

#### 모듈 css 
팀 프로젝트 및 협업 상황에서 클래스명이 겹치는 경우가 종종 발생한다.   
클래스명이 겹치면 우선순위에 따라 내가 원하는 스타일이 적용되지 않을 수 있다.   
이런 상황을 방지하기 위해 모듈 css를 사용한다.   

모듈 css는 .css 확장자 앞에 .module를 붙이고
```
사용할css파일명.module.css
```
해당 모듈 css를 사용할 jsx 파일에 모듈 css를 임포트 하여 사용한다.   
styles의 경우 apple, water 등 원하는 이름을 붙이면 된다.   
임포트한 styles는 모듈 css의 내용을 가지고 있는 객체가 된다.
```
import styles from './~.module.css';
```
불러온 모듈 css에서 사용할 클래스명에 '_' 등 특수기호가 들어가는 경우   아래처럼 객체[키 값] 형태로 클래스를 불러올 수 있다.
```
className={styles['class_list']}
```  
특정 css 코드만 사용할 경우 디스트럭쳐링 해서 사용할 수 있다.
```
const { text, remove, 'todo-list-item': itemStyle, 'check-circle': checkCircle, active, finish } = styles;
```


---

#### 연습문제: 투두리스트 만들기
props, 이벤트 바인딩, useState, 동적, 조건부 렌더링, 동적 스타일링을 활용하여   
todo리스트에 할 일을 추가하고 관리하는 프로그램을 만들며 전체 복습을 진행했다.

1. 버튼 클릭 시 인풋 창 노출 토글    

![alt text](/img/image-5.png) 
![alt text](/img/image-6.png)   

논리값을 저장하고 관리하는 상태 변수를 하나 만들고 버튼 클릭 시 논리값을 반전시켰다.   
논리값의 이름을 isOpened로 하여 isOpened가 true면 버튼이 클릭되고 인풋 폼이 노출된   
상태임을 알기 쉽게 명명했다.   
```
// =============== 상태 관리 =============== //
const[isOpened, setIsOpened] = useState(false);

// =============== 핸들러 =============== //
const openBtnHandler = e => {
    setIsOpened(prev => !prev);
}
```
인풋 폼의 경우 따로 변수에 저장하여 isOpened가 true 일때만 렌더링 될 수 있게 작성했다.
```
const formContent =
    <div className={wrapper}>
        <form className={insertForm} onSubmit={addTodoHandler}>
            <input
                type='text'
                placeholder='할 일을 입력 후, 엔터를 누르세요!'
                onInput={todoInputHandler}
                value={todo.todo}
            />
        </form>
    </div>;

return (
    <>
        {isOpened ? formContent: ''}
        <button
            className={`${insertBtn} ${isOpened ? open : ''}`}
            onClick={openBtnHandler}
        >
            <MdAdd />
        </button>
    </>
);
```

2. 인풋 폼에 입력한 값을 todo 리스트에 추가   

![alt text](/img/image-7.png)   

인풋 폼에 입력한 값을 App.js 에서 todo 리스트로 추가하기 위해서 먼저 컴포넌트들의 구조를 확인했다.   
```
App             
├── TodoTemplate
│   ├── TodoHeader 
│   ├── TodoMain
│   │   ├── TodoItem
│   └── TodoInput
```
App.js에서 TodoInput의 값을 받아와야 하는 상황으로 App.js에서 props 통해    
TodoInput으로 부터 값을 받아올 함수를 작성하고    
더미 데이터와, 리스트를 관리할 상태관리 변수도 작성했다.
```
// 더미 데이터 리스트
const todoList = [
    {
        id: 't1',
        todo: '할 일 어쩌구~~',
        finish: false,
    },
    {
        id: 't2',
        todo: '할 일 어쩌구~~',
        finish: false
    }
]

// todo 리스트 상태 관리 변수
const [todos, setTodos] = useState(todoList);

// 데이터를 끌어올려올 함수
const onAddTodo = (item) => {
    // console.log(item)
    setTodos(prev => [...prev, item])
}
```
끌어올려진 데이터가 상태관리 setState로 리스트에 추가되는 것을 확인한 후   
리스트의 값을 렌더링하기 위해 자식들에게 props todos를 통해 데이터를 보내주었다.
```
return <TodoTemplate onAdd={onAddTodo} todos = {todos} />
```

3. 데이터 렌더링 및 완료 처리   

![alt text](/img/image-8.png)  

App.js로부터 TodoTemplate에게 전달된 todos를 TodoTemplate이 다시 TodoTemplate에게 보내고 렌더링을 한다.   
입력 폼에서 App.js로 값을 끌어올리는 함수도 onAdd props를 통해 TodoTemplate을 거쳐 TodoInput까지 전달되고 있다.
```
const TodoTemplate = ({onAdd, todos}) => {
    return (
        <div className={styles.TodoTemplate}>
            <TodoHeader/>
            <TodoMain todos={todos}/>
            <TodoInput onAdd={onAdd}/>
        </div>
    );
};
```
여기서 받은 todos는 todoList로 TodoMain에서는 todoList의 todo를 하나씩 꺼내서 id, todo 등을 분해하여 다시 TodoItem으로 전달한다.   
```
return (
    <ul className={styles['todo-list']}>
        {
            todos.map(todo => <TodoItem
                    key={todo.id}
                    id={todo.id}
                    todo={todo.todo}
                    onCancel={onCancel}
                    onFinish={onFinish}
                />)
        }
    </ul>
);
```

4.
![alt text](/img/image-9.png)


---

### 🚨 트러블슈팅
#### 🛠️ 문제와 원인
- 문제: 렌더링 무한 루프(Uncaught Error: Too many re-renders. React limits the number of renders to prevent an infinite loop.)
- 원인: setToggle() 를 함수로 전달해야되는데 직접 호출해서 문제 발생   
**() => {setToggle()}** 화살표 함수로 setToggle(false) 함수 자제를 전달하여 이벤트가 발생할 때마다 실행된다. 에러가 난 코드는 컴포넌트가 렌더링 될 때마다 함수가 실행되어 무한루프가 발생하고 있다.

#### ✅ 해결 방법
콜백으로 setToggle() 함수를 전달하도록 수정했다.
```
// 직접 setToggle 함수를 호출
const formComponent = <ExpenseForm onSave={onSave} onCancel={setToggle(false)}/>

// 콜백으로 함수 전달 
const formComponent = <ExpenseForm onSave={onSave} onCancel={() => setToggle(false)}/>
```

---

#### 🛠️ 문제와 원인
- 문제: CourseGoal 연습문제 중 setGoal 호출 후 console.log(goals)로 출력하면 업데이트된 값이 아닌 이전 값이 출력된다.
- 원인: 리액트의 상태 업데이트는 비동기적으로 처리되며 setState 호출 즉시 상태가 변경되지 않고 다음 렌더링 사이클에서 반영된다.

#### ✅ 해결 방법
상태 자체는 정상적으로 업데이트되고 있으며, 단순히 콘솔 출력 타이밍의 문제였다. 코드 수정이 필요한 상황이 아니었다.

---

#### 🛠️ 문제와 원인
- 문제: 배열에서 특정 요소를 삭제하려고 pop()을 사용했지만 원하던 요소가 아닌 배열 맨 끝 요소가 삭제된다.
- 원인: pop()은 배열의 마지막 요소만 제거하는 메서드로, 특정 조건이나 위치의 요소 삭제에는 사용할 수 없다.
```
 const onCancelGoal = (id) => {
        for(const goal of goals) {
            if(goal.id === id) {
                goals.pop(id);
                break;
            }
        }
        const newGoals = [...goals];

        setGoals(() => [...newGoals])
    }
```

#### ✅ 해결 방법
splice를 사용하여 문제를 해결하려 했지만 원하는 요소가 삭제되지 않는 문제가 다시 발생했다.   
goals는 상태변수로 관리되는 배열인데 바로 goals에서 변경을 하려니까 제대로 렌더링 되지 않았고,   
splice 에도 인덱스 값을 넣지 않아서 제대로 삭제 동작이 실행되지 않았다.
```
const onCancelGoal = (id) => {
    for(const goal of goals) {
        if(goal.id === id) {
            goals.splice(id, 1);
            break;
        }
    }
    const newGoals = [...goals];

    setGoals(() => [...newGoals])
}
``` 
newGoals의 위치를 변경하고,  
```
const onCancelGoal = (id) => {
    const newGoals = [...goals];
    let index = -1;
    for (let i = 0; i < newGoals.length; i++) {
      if (newGoals[i].id === id) {
        index = i;
        break;
      }
    }
    
    if (index !== -1) {
      newGoals.splice(index, 1);
      setGoals(newGoals);
    }
}
``` 
위의 코드로 수정하여 원하는 동작이 실행됨을 확인했다.   
현재 코드보다 더 좋은 방법을 찾아보던 중 filter를 사용하여 제거하는 방법을 추천받았다. 
```
setGoals(prev => prev.filter(goal => goal.id !== id))
```
filter(), map() 등 배열고차함수를 활용하면 상태변경 시 원본을 변경하지 않고 새로운 배열, 객체를 생성하여 리액트의 불변성 원칙을 지키고 조건부 렌더링을 할 수 있다는 것을 알게되었다.

#### 💡 추가로 알게 된 내용
- 메모리 관리: 새 객체로 상태 변경을 진행하면 기존 객체는 메모리에 그대로 남아있다가,   
더 이상 참조되지 않으면 자바스트립트 가비지 컬렉터가 자동으로 메모리에서 정리한다.

