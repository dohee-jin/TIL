## TIL - 2025.08.27

### 🔍 오늘 배운 내용
- 동적 스타일링
- 모듈 css
- 연습문제: 투두리스트 만들기

---

#### 동적 스타일링   
동적, 조건부 렌더링과 마찬가지로 스타일링도 동적으로 반영할 수 있다.  
isValid 값에 따라 invalid 클래스가 동적으로 삽입되고 있다. 
```
<div className={`form-control ${isValid === false ? 'invalid' : ''}`}>
```
인라인으로도 스타일을 추가 할 수 있다. 
```
style={{color: 'red'}}
```

---

#### 모듈 css 
팀 프로젝트 및 협업 상황에서 클래스명이 겹치는 경우가 종종 발생한다.   
클래스명이 겹치면 우선순위에 따라 내가 원하는 스타일이 적용되지 않을 수 있다.   
이런 상황을 방지하기 위해 모듈 css를 사용한다.   

모듈 css는 .css 확장자 앞에 .module를 붙이고
```
사용할css파일명.module.css
```
해당 모듈 css를 사용할 jsx 파일에 모듈 css를 임포트 하여 사용한다.   
styles의 경우 apple, water 등 원하는 이름을 붙이면 된다.   
임포트한 styles는 모듈 css의 내용을 가지고 있는 객체가 된다.
```
import styles from './~.module.css';
```
불러온 모듈 css에서 사용할 클래스명에 '_' 등 특수기호가 들어가는 경우   아래처럼 객체[키 값] 형태로 클래스를 불러올 수 있다.
```
className={styles['class_list']}
```  
특정 css 코드만 사용할 경우 디스트럭쳐링 해서 사용할 수 있다.
```
const { text, remove, 'todo-list-item': itemStyle, 'check-circle': checkCircle, active, finish } = styles;
```


---

#### 연습문제: 투두리스트 만들기
props, 이벤트 바인딩, useState, 동적, 조건부 렌더링, 동적 스타일링을 활용하여   
todo리스트에 할 일을 추가하고 관리하는 프로그램을 만들며 전체 복습을 진행했다.

1. 버튼 클릭 시 인풋 창 노출 토글    

![alt text](/img/image-5.png) 
![alt text](/img/image-6.png)   

논리값을 저장하고 관리하는 상태 변수를 하나 만들고 버튼 클릭 시 논리값을 반전시켰다.   
논리값의 이름을 isOpened로 하여 isOpened가 true면 버튼이 클릭되고 인풋 폼이 노출된   
상태임을 알기 쉽게 명명했다.   
```
// =============== 상태 관리 =============== //
const[isOpened, setIsOpened] = useState(false);

// =============== 핸들러 =============== //
const openBtnHandler = e => {
    setIsOpened(prev => !prev);
}
```
인풋 폼의 경우 따로 변수에 저장하여 isOpened가 true 일때만 렌더링 될 수 있게 작성했다.
```
const formContent =
    <div className={wrapper}>
        <form className={insertForm} onSubmit={addTodoHandler}>
            <input
                type='text'
                placeholder='할 일을 입력 후, 엔터를 누르세요!'
                onInput={todoInputHandler}
                value={todo.todo}
            />
        </form>
    </div>;

return (
    <>
        {isOpened ? formContent: ''}
        <button
            className={`${insertBtn} ${isOpened ? open : ''}`}
            onClick={openBtnHandler}
        >
            <MdAdd />
        </button>
    </>
);
```

2. 인풋 폼에 입력한 값을 todo 리스트에 추가   

![alt text](/img/image-7.png)   

인풋 폼에 입력한 값을 App.js 에서 todo 리스트로 추가하기 위해서 먼저 컴포넌트들의 구조를 확인했다.   
```
App             
├── TodoTemplate
│   ├── TodoHeader 
│   ├── TodoMain
│   │   ├── TodoItem
│   └── TodoInput
```
App.js에서 TodoInput의 값을 받아와야 하는 상황으로 App.js에서 props 통해    
TodoInput으로 부터 값을 받아올 함수를 작성하고    
더미 데이터와, 리스트를 관리할 상태관리 변수도 작성했다.
```
// 더미 데이터 리스트
const todoList = [
    {
        id: 't1',
        todo: '할 일 어쩌구~~',
        finish: false,
    },
    {
        id: 't2',
        todo: '할 일 어쩌구~~',
        finish: false
    }
]

// todo 리스트 상태 관리 변수
const [todos, setTodos] = useState(todoList);

// 데이터를 끌어올려올 함수
const onAddTodo = (item) => {
    // console.log(item)
    setTodos(prev => [...prev, item])
}
```
끌어올려진 데이터가 상태관리 setState로 리스트에 추가되는 것을 확인한 후   
리스트의 값을 렌더링하기 위해 자식들에게 props todos를 통해 데이터를 보내주었다.
```
return <TodoTemplate onAdd={onAddTodo} todos = {todos} />
```

3. 데이터 렌더링 및 완료 처리   

![alt text](/img/image-8.png)  

App.js로부터 TodoTemplate에게 전달된 todos를 TodoTemplate이 다시 TodoTemplate에게 보내고 렌더링을 한다.   
입력 폼에서 App.js로 값을 끌어올리는 함수도 onAdd props를 통해 TodoTemplate을 거쳐 TodoInput까지 전달되고 있다.
```
const TodoTemplate = ({onAdd, todos}) => {
    return (
        <div className={styles.TodoTemplate}>
            <TodoHeader/>
            <TodoMain todos={todos}/>
            <TodoInput onAdd={onAdd}/>
        </div>
    );
};
```
여기서 받은 todos는 todoList로 TodoMain에서 todoList의 todo를 하나씩 꺼내서 id, todo 등을 분해하여 다시 TodoItem으로 전달한다.   
```
return (
    <ul className={styles['todo-list']}>
        {
            todos.map(todo => <TodoItem
                    key={todo.id}
                    id={todo.id}
                    todo={todo.todo}
                    onCancel={onCancel}
                    onFinish={onFinish}
                />)
        }
    </ul>
);
```
렌더링이 완료된 todo를 완료 처리하기 위해 다시 App.js에서 아래 코드를 작성했다.    
todo 추가 함수와 마찬가지로 자식 컴포넌트로부터 데이터(삭제할 todo id)를 끌어와서   
삭제할 todo 제외하고 todoList의 상태를 변경하여 리렌더링을 진행한다.  
```
const onCancelTodo = (item) => {
    console.log(`삭제할 todo:`, item);
    setTodos(prev => prev.filter(todo => todo.id !== item));
}

return <TodoTemplate onAdd={onAddTodo} todos = {todos} onCancel={onCancelTodo}/>
```
onCancelTodo 함수를 실행할 자식 컴포넌트 TodoItem에서는 삭제 버튼을 클릭하면   
이벤트 핸들러를 통해 todo 의 id를 App.js로 보내주고 있다.
```
// todo 취소 이벤트 핸들러
const cancelTodoHandler = e => {
    if(e.target.closest('li')) {
        onCancel(id);
    }
}

 return (
    <li className={itemStyle} id={id}>
        .
        .
        <div className={remove} onClick={cancelTodoHandler}>
            <MdDelete />
        </div>
    </li>
);
```
todo 완료 처리도 App.js에서 todoList > todo 의 finish 상태를 변경해야 하기 때문에   
App.js에서 완료처리를 진행할 함수를 작성한다. onFinishTodo 함수 역시 props로   
자식컴포넌트에서 id 값을 받아오고 있다.   
filter로 todo.id가 파라미터(id)와 같을때 해당하는 todo의 finish를 반전시킨다.   
```
const onFinishTodo = (id) => {
    setTodos(prev => prev.map(todo => {
        if (todo.id === id) {
            todo.finish = !todo.finish;
            return todo;
        } else {
            return todo;
        }
    }))

}

return (
    return <TodoTemplate onAdd={onAddTodo} todos = {todos} onCancel={onCancelTodo} onFinish={onFinishTodo}/>
)
```
TodoItem에서는 checkCircle을 누르면 부모 컴포넌트로 부터 props로 받은 onFinish에 id 값을 넣어 보내어 완료 상태를 토글할 수 있다.
```
return (
    .
    .
    <div className={`${checkCircle} ${finish ? active : ''}`} onClick={() => onFinish(id)}>
        { finish && <MdDone /> }
    </div>
    .
    .
)
```

4. 남은 todo 개수 세기, 현재 날짜로 변경하기   

![alt text](/img/image-9.png)

남은 todo 개수는 todoList에서 todo의 상태가 false인 todo만 필터링하여 배열의 크기를 반환받아 구한다. 구한 값은 props로 보내어 렌더링을 진행한다.
```
<TodoHeader length={todos.filter(todo => todo.isFinish !== true).length}/>
```

날짜는 new Date와 toLocaleString을 이용하여 원하는 포맷으로 만들었다.
```
const TodoHeader = ({length}) => {
    const { 'day': date, 'tasks-left': left } = styles;
    const today = new Date()
    const year = today.getFullYear().toLocaleString().replace(',', '');
    const month = `${today.getMonth() + 1}`;
    const day = today.getDate().toLocaleString();
    console.log()

    return (
        <header>
            <h1>{year}년 {month}월 {day}일</h1>
            <div className={date}>{today.toLocaleString('ko-kr', {weekday: 'long'})}</div>
            <div className={left}>할 일 {length}개 남음</div>
        </header>
    );
};
```

---

### 🚨 트러블슈팅
#### 🛠️ 문제와 원인
- 문제: **할 일 완료 토글** 처리 시 TodoMain으로 todoList가 넘어가지 않는 문제
- 원인: setTodos 내부의 map 함수에서 return 문이 누락되어 undefined가 반환되면서 상태 업데이트가 실패

#### ✅ 해결 방법
map에서 조건문을 사용하여 해당 id의 todo 객체를 찾아 finish 값을 직접 수정하고   
수정된 객체를 포함한 새 배열을 반환하도록 구현하여 문제를 해결했다.
```
 const onFinishTodo = (id) => {
    setTodos(prev => prev.map(todo => {
        if (todo.id === id) {
            todo.finish = !todo.finish;
            return todo;
        } else {
            return todo;
        }
    }))

}
```

