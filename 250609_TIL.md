## TIL - 2025.06.09

### 🔍 오늘 배운 내용

#### JavaScript - 디스트럭처링 할당, 스프레드, 단축평가, 배열 고차 함수

- 디스트럭처링 할당
> 배열의 값, 객체의 프로퍼티 값을 분해하여 변수에 쉽게 할당할 수 있다. 파이썬의 언패킹과 유사한 기능. 배열는 순서에 따라 값이 분해되고 객체는 프로퍼티 값에 따라 분해됨

```
//  배열 분해
const numbers = [10, 20, 30];
const[first, second, third] = numbers;
console.log(first); // 10 출력
console.log(second); // 20 출력
console.log(third); // 30 출력

// 객체 분해
const person = {
    personName: '타롱이',
    personAge: '25',
    birthDay: '2000-11-25'
}
// 객체 프로퍼티에 접근하는 방법
console.log(person.personName);

// 객체 분해 후 변수로 접근하는 방법1
const {personName, personAge, birthDay} = person;
console.log(personName); // '타롱이' 출력
console.log(personAge); // 25 출력
console.log(birthDay); '2000-11-25' 출력

// 객체 분해 시 변수 이름 변경
const {personName: name, personAge: age, birthDay: birth} = person // name, age, birth로 접근 가능
console.log(name);
console.log(age);
console.log(birth);
```

- 스프레드
> 원하는 작업을 위해 배열의 원소, 객체의 프로퍼티를 해체. '...' 키워드를 사용한다. 

```
// 두 개의 배열을 하나의 배열로 만들때
const number1 = [10, 20, 30];
const number2 = [40, 50, 60];

const number = [...number1, number2];

// 배열을 복사할 때
const copyNumber = [...number1]

// 객체를 복사할 때
const person = {
    name: '타로쨩',
    age = 25,
}

const copyPerson = {...person}

// 새 객체에 다른 객체 내용을 가져올 때
conset newPerson = {
    ...person,
    likes: ['춤', '단것'],
}
```
위의 내용 이외에 다양한 작업에서 사용될 수 있다.

- 단축 평가(short circuit)
> 논리 연산시 좌항에서 결과가 결정되는 경우 우항의 연산을 무시

```
// and
// 모두 true 일때만 true를 반환
true && true -> 1 * 1 = 1 -> true
true && false -> 1 * 0 = 0 -> false
false && true -> 0 * 1 = 0 -> false
false && false -> 0 * 0 = 0 -> false

// 좌항이 true 면 결정자가 우항이기 때문에 우항의 결과가 뜸 
console.log('hello' && 0) // true && false -> 0
// 좌항이 false면 우항이 true 여도 false이기 때문에 단축 평가로 우항을 판단하지 않고 좌항의 결과값만 출력함
console.log(null && '메롱') // false && true -> null

// or
// 하나라도 1이 있으면 true를 반환
true || true -> 1 + 1 = 1 -> true
true || false -> 1 + 0 = 1 -> true
false || true -> 0 + 1 = 1 -> true
false || false -> 0 + 0 = 0 -> false

// 좌항이 true면 우항의 결과값과 상관없이 true이기 때문에 단축 평가로 우항을 판단하지 않고 좌항의 결과값만 출력함
console.log('hello' || null) // true && false -> hello
// 좌항이 false면 결정자가 우항이기 때문에 우항의 결과가 뜸
console.log(0 || '메롱') // false && true -> 메롱 
```

- 배열 고차 함수
> 함수의 파라미터를 다른 함수를 받거나 반환 값으로 함수를 반환하는 함수

1. forEach()
: 배열의 반복문을 깔끔하게 처리, for-of, for-i 문의 장점을 합침, 리턴이 없음
```
// forEach 사용
const numbers = [1, 2, 3, 4, 5];
numbers.forEach(function (파라미터){
    함수 내용;
    반환값 없음
}) 
// 화살표 함수로 사용
numbers.forEach((파라미터) => {
    함수 내용;
})
// ex) 배열 원소 값 중 짝수만 출력
// 파라미터 값이 하나, 함수 내용이 1줄이면 괄호 삭제 해도 됨.
numbers.forEach(num => if(num % 2 == 0) console.log(num));
```

2. filter()
: 함수 내용에 맞는 값만 필터링, 10개의 데이터에서 필터링하면 개수의 변경이 있음, 
[{}, {}, {}, {}] -> [{}, {}]
```
// filter 사용
const numbers = [1, 2, 3, 4, 5];

// 필터는 반환값이 있기 때문에 변수에 받는다
const 변수명 = filter(callback);
const filterNumber = filter(function(number){
    return 필터링 조건;
    // 필터링 조건에 걸린 것들만 반환
})

// 화살표 함수 사용
const filterNumber = filter(number => number % 2 == 0);
```

3. map()
: 함수 내용에 맞는 특정 데이터들을 추출해서 새 배열에 저장, 10개의 데이터를 매핑해도 개수의 변경 없음
[{}, {}, {}, {}] -> ['', '', '', '',]
```
// map 사용
const numbers = [1, 2, 3, 4, 5];

// 맵도 반환값이 있기 때문에 변수에 받는다, 이 때 변수 타입은 Array가 된다.
const 변수명 = map(callback);
const mappingNumber = map(function(number){
    함수 내용
})

// 화살표 함수 사용
const mappingNumber = map(number => number[0]) 
```

4. find() / findIndex()
: find - 주어진 조건에 일치하는 "처음" 발견된 객체데이터의 인덱스를 반환 / findIndex() - 주어진 콜백조건에 맞는 처음 발견된 객체데이터의 인덱스를 반환
```
// find 사용
const 변수명 = 배열.find(callback()){

}
```
5. some()
6. every()
7. reduce()
8. sort()

