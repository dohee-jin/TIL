## TIL - 2025.09.01

### 🔍 오늘 배운 내용
- 리액트 + 백엔드 프로젝트 설정
- loader 


![alt text](/img/image-19.png)   
```
export const eventItemLoader = async (x) => {
    //const response = await fetch(`${DEFAULT_URL}/${eventId}`)
    console.log(x)
    //return response;
}
```

---

#### 리액트 + 백엔드 프로젝트 설정   
두가지 언어로 풀스텍 프로젝트를 만들기 위해 인텔리제이로 프로젝트 기본 설정을 진행했다.   

1. 빈 프로젝트 생성   

![alt text](/img/image-20.png)   

2. 모듈로 백엔드 / 프론트엔드 환경 설정   

![alt text](/img/image-21.png)   

모듈로 각 환경에 맞는 설정을 진행하고 아래 사진과 같이 backend / frontend로 폴더 구조를 설정하면 된다.

![alt text](/img/image-22.png)   

3. 백엔드 서버 헬스 체크   
서버의 상태를 확인할 컨트롤러를 작성하고 테스트한다.   
```
@RestController
@Slf4j
public class HealthCheckController {
    @GetMapping("/status")
    public ResponseEntity<?> healthCheck() {
        return ResponseEntity.ok(
                Map.of(
                        "healthy", true,
                        "timestamp", LocalDateTime.now()
                )
        );
    }
}
```
![alt text](/img/image-23.png)   
이렇게 json이 뜨면 서버가 정상적으로 작동하고 있음을 확인할 수 있다.   
프론트엔드 서버도 확인이 완료되었으면 각 폴더에서 코드를 작성하면 된다.

- record   
> 데이터 중심의 클래스를 간결하고 효율적으로 정의할 수 있도록 도와주는 자바의 새로운 데이터 구조

record 키워드로 정의되는 클래스로 불변성을 가진 데이터를 쉽게 다룰 수 있게 해준다.  
레코드는 DTo를 더 간단하고 안전하게 정의할 수 있도록 설계되었다.   
모든 필드가 final이며 getter, setter, toString, hasCode 등을 자동으로 생성해 준다.   

레코드의 필드는 메소드의 매개변수 처럼 ()안에 작성하며 모든 필드는 private final로 선언된다.
```
@Builder
public record EventResponse(
        String eventId,
        String title,
        @JsonFormat(pattern = "yyyy-MM-dd")
        LocalDate startDate,
        String imgUrl
) {

    // 엔터티를 Dto로 바꿔주는 편의 메소드
    public static EventResponse from(Event event) {
        return EventResponse.builder()
                .eventId(event.getId().toString())
                .imgUrl(event.getImage())
                .title(event.getTitle())
                .startDate(event.getDate())
                .build();
    }
}
```
.getTitle() .get... ()으로 사용하던 getter를 자동으로 생성해주는데   
.title(), ..() 으로 사용할 수 있다.

---

#### loader
저장된 데이터를 프론트엔드로 가져오기 위해 api 호출을 컴포넌트에서 실행했다.   
```
const EventPage = () => {
    const [eventList, setEventList] = useState([]);

    const fetchEvent = async () => {
        const response =  await fetch(`${DEFAULT_URL}`);
        const data = await response.json();

        console.log(data);

        setEventList(data);
    }

    ...
}
```
fetchEvent()를 컴포넌트 안에서 직접 호출하면 다음과 같은 문제점이 발생한다.   
컴포넌트가 렌더링 -> fetchEvent() 실행 -> setEventList()로 다시 렌더링 ->
다시 api 요청 -> setEventList() ... 무한 루프 발생. 

문제를 해결하기 위해 useEffect 안으로 옮겨 페이지 로딩 시 한 번만 실행되도록 변경했다.   
```
useEffect(() => {
   fetchEvent();
},[])
```
그러나 useEffect를 사용하면 컴포넌트가 먼저 렌더링된 후에 API 호출이 실행되므로,      
![alt text](/img/image-24.png)

호출되는 동안 초기 화면(빈 화면)이 잠시 노출될 수 있어 사용자 경험이 떨어질 수 있다. 

- loader 함수   
**loader 함수**를 사용하면 페이지가 렌더링 되기 전에 데이터를 미리 가져올 수 있다.   
로더 함수는 페이지가 라우팅 될 때 실행 되기 때문에 라우터 설정으로 이동하여   
api 요청을 할 페이지에 >> **loader: 함수** << 을 작성한다.
```
...
{
    index: true,
    element: <EventPage />,
    loader: async () => {
        const res = await fetch(`http://localhost:9000/api/events`);
        return res;
    },
}
...
```
로더는 내부적으로 await response.json()를 실행하여 코드를 더 간결하고 편리하게 작성할 수 있다.   
또한, 로더가 리턴한 데이터는 라우팅된 페이지와 그 하위 컴포넌트에서 언제든 사용가능하다.   

- loader 함수 작성 시 주의할 점   
    1. 항상 Promise를 반환해야 함. -> 항상 리턴이 있어야 함
    2. 에러 처리 필요 -> ErrorElement와 연계하여 사용
    3. 과도한 데이터 로딩 주의 -> 필요한 데이터만 로딩

- useLoaderData   
로더에서 리턴한 데이터를 가져오기 위해 사용한다.    
```
const eventList = useLoaderData();
```

- loader 아웃소싱   
로더를 여러 개 사용하다보면 route 설정파일이 길어지고, 코드 관리와 재사용이 어려워지고 가독성이 떨어지게 되는데 로더만 관리하도록 파일을 분리하여 아웃소싱을 한다.   
loader 폴더를 생성하고 loader.js 파일을 생성하여 안에 로더 코드를 작성한다.
```
export const eventListLoader = async () => {
    const response = await fetch(`http://localhost:9000/api/events`);
    return response;
}
```
아웃소싱한 로더를 라우터 설정파일로 임포트하여 loader: 에 작성하면 된다.

```
...
{
    index: true,
    element: <EventPage />,
    loader: eventListLoader,
}
...
```

- loader 동적 파라미터 처리   
react router는 로더에게 객체로 세가지 정보: context, params, request 를 전달하는데   
params 를 통해 파라미터로 사용되는 id 값을 가져올 수 있다.
```
export const eventItemLoader = async ({ params }) => {
    const response = await fetch(`http://localhost:9000/api/events/${params.eventId}`)
    return response;
}
```

