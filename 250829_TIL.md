## TIL - 2025.08.29

### 🔍 오늘 배운 내용
- 리액트 페이지 라우팅
- 동적 라우팅
- 중첩 라우팅

---

#### 리액트 페이지 라우팅
- React Router   
> 라우팅은 사용자가 웹사이트 내에서 특정 URL을 요청했을 때 해당 URL에 맞는 페이지나 컴포넌트를 보여주는 시스템이다.

> 단일 페이지 애플리케이션(SPA)은 서버에서 필요한 데이터만 비동기로 받아와서 동적으로 현재 화면에 다시 렌더링해서 보여주는 방식으로 페이지가 새로고침 되지않고 전환되는 느낌을 준다.

리액트는 React Route를 통에 SPA 라우팅을 지원한다. React Route를 사용하기 위해서 먼저 설치가 필요하다.   
새 프로젝트 생성 후 터미널 창에 아래 명령어를 입력하고 React Router 라이브러리를 설치한다.   
sass도 함께 설치했다.     
```
npm install sass react-router-dom
```

라우터는 페이지 단위로 라우팅을 하기 때문에 pages 폴더를 만들어 각 경로에 대응되는 Page 컴포넌트를 관리한다.   
페이지 내부에서 재사용되거나 세부 UI를 담당하는 컴포넌트들은 components 폴더에 따로 두어 관리할 수 있도록 폴더 구조를 분리하였다.   

![alt text](/img/image-10.png)   

createBrowserRouter() 사용하여 라우팅을 관리할 config 파일을 만들었다.   
```
import {createBrowserRouter} from "react-router-dom";

export const router = createBrowserRouter([
    {
        path: '/',
        element: <IndexPage />
    },
    {
        path: '/blog',
        element: <BlogPage />
    },
    {
        path: '/about',
        element: <AboutPage />
    }
]);
```
RouterProvider로 App.js에서 적용한다.
```
import {RouterProvider} from "react-router-dom";
import {router} from "./routes/router-config.jsx"

const App = () => {
    return (
      <RouterProvider router={router} />
    );
};
```
createBrowerRouter()로 라우팅을 관리하고 RouterProvider로 라우팅을 적용한다.   


- Link 컴포넌트   
보통 Html에서 링크 이동은 a태그를 사용하지만 React Router에서는 Link 컴포넌트를 사용한다.   
```
return (
    <nav className={nav}>
        <Link to="/" className={navLink}>Home</Link>
        <Link to="/blog" className={navLink}>blog</Link>
        <Link to="/about" className={navLink}>about</Link>
    </nav>
);
```
a 태그와 location.href="" 새로고침을 일으켜 UX적으로 화면 깜빡임을 유발하고, 상태값을 초기화 시키기 때문에 좋지 않다.   
리액트에서는 부드러운 화면 전환을 위해 새로고침을 유발하는 태그와 코드 대신 Link 컴포넌트와   
useNavigate() 훅을 지원한다.    

useNavigate() 훅은 새로고침없이 리다이렉션을 지원하고 함수를 리턴하는 훅이다.
```
const navigate = useNavigate();
const handleCategoryClick = (e) => {
    // 사이드바에 있는 카테고리를 누르면 목록으로 이동하면서 카테고리를 보여줘야 함.
    // location.href = '/blog';
    navigate(`/blog`);
};

return (
    <button onClick={handleCategoryClick}>
);
```

- NavLink 컴포넌트   
NavLink 컴포넌트는 네비게이션의 active 처리를 간단하게 구현할 수 있게 한다.   
```
const activate = (x) => {
    console.log(x);
}

<NavLink to="/" className={activate}>Home</NavLink>
```
NavLink 클릭했을 때 x를 콘솔 로그로 찍으면 아래 이미지에서 보이듯이 isActive 값을 확인할 수 있다.   
![alt text](/img/image-11.png)   

이 isActive 값을 디스트럭처링 하여 동적으로 active 클래스를 부여해서   
active 처리를 간단하게 구현할 수 있다.
```
// 현재 링크이동한 링크에 active 표시하기
const activate = ({ isActive }) => {
    return `${navLink} ${isActive ? active : ''}`
}

return (
    <nav className={nav}>
        <NavLink to="/" className={activate}>Home</NavLink>
        <NavLink to="/blog" className={activate}>blog</NavLink>
        <NavLink to="/about" className={activate}>about</NavLink>
    </nav>
);
``` 
Link와 NavLink를 정리했다. 앞으로 프로젝트 작업할 때 필요한 곳에 적절하게 사용하면 될 것 같다.

| 태그          | 주요 용도                                 | 특징                                 |
| ----------- | ------------------------------------- | ---------------------------------- |
| **Link**    | 1. 단순 경로 이동<br>2. 버튼 클릭 시 이동          | 경로만 변경, Active 상태 표시 없음            |
| **NavLink** | 1. 메뉴/네비게이션 이동<br>2. Active 처리가 필요한 곳 | 현재 경로와 일치하면 자동으로 Active 클래스/스타일 적용 |


- 레이아웃 만들기   
**레이아웃(Layout)**은 홈페이지에서 공통적으로 반복되는 영역(예: 헤더, 푸터, 사이드바 등)을 한 번에 관리하기 위해 만드는 페이지 구조다.   
각 페이지마다 중복해서 넣으면 비효율적이므로 레이아웃을 두어 공통 요소를 묶고 그 안에서 개별 페이지 콘텐츠만 교체되도록 구성한다.   
```
import {Outlet} from "react-router-dom";

const RootLayout = () => {
    return (
        <MainNav />
        {/* 실제로 바뀌는 동적인 부분 */}
        <Outlet />
    );
};
```
Outlet에는 라우트 설정에서 정의한 내용에 따라 바뀔 페이지가 동적으로 렌더링된다.   
위에서 작성했던 createBrowerRouter()를 수정했다.   
children: [] 배열안에 객체로 라우팅 할 내용들을 작성해주었다.   
최상단 path: '/' 가 있기 때문에 children의 path에는 '/'를 빼도 되고   
path가 빈문자열이 들어올 때는 index: true라고 작성하면 된다.
```
export const router = createBrowserRouter([
    {
        path: '/',
        element: <RootLayout />,
        // children -> Layout의 Outlet 부분을 뭘로 바꿀지를 설정
        children: [
            {
                index: true,
                element: <IndexPage />
            },
            {
                path: 'blog',
                element: <BlogPage />
            },
            {
                path: 'about',
                element: <AboutPage />
            },
        ]
    },
]);
```

- 에러페이지 처리   
에러페이지도 커스텀 에러페이지를 만들어서 라우팅 할 수 있다.   
pages에 ErrorPage를 추가하고 에러가 발생했을 때 해당 페이지가 라우팅되도록 createBrowerRouter()에 ErrorPage를 추가한다.
```
export const router = createBrowserRouter([
    {
        path: '/',
        element: <RootLayout />,
        errorElement: <ErrorPage />
        children: [
            {
                index: true,
                element: <IndexPage />
            },
        ]
    },
]);

```
에러를 발생시켜(없는 페이지 요청 등등) 확인하면 에러페이지가 라우팅 되는 것을 확인할 수 있다.

![alt text](/img/image-12.png)   
useRouteError() 훅을 사용하여 발생한 에러정보를 가져와 변수에 저장한다.   
```
 // 발생한 에러 정보 (throw로 던져지거나 404에러 발생시)를 가져오기
const error = useRouteError();
console.log(error)

```
![alt text](/img/image-13.png)   
useRouteError가 발생한 에러 정보를 객체를 가져오고 있다.   

```
return(
    <p className={styles.message}>
        {
            error.status === 404 ? '페이지를 찾을 수 없습니다' : error.message
        }
    </p>
)
```
에러객체에서 가져온 텍스트를 에러 상태에 따라 동적으로 텍스트를 변경할 수도 있다.   
에러도 createBrowerRouter children 안에 추가할 수 있다.
```
export const router = createBrowserRouter([
    {
        path: '/',
        element: <RootLayout />,
        errorElement: <ErrorPage />
        children: [
            {
                index: true,
                element: <IndexPage />,
                errorElement: <IndexErrorPage />
            },
        ]
    },
]);
```
인덱스 페이지에서 에러가 터지면 가까이에 있는 IndexErrorPage가 라우팅되고   
다른페이지에서도 자신의 페이지와 가까이에 있는 에러페이지가 에러를 처리한다.   

---

#### 동적 라우팅
- url 파리미터 사용   
![alt text](/img/image-14.png)   

리스트에서 상세페이지로 이동할 때 보통 url: '/blog/id' <- 이런식으로 이동한다.   
동적으로 선택한 리스트로 이동되게 createBrowerRouter() 에 상세페이지를 라우팅할 객체를 추가한다.   
path에 path:'**기존path/:원하는이름**' 를 넣어 추가한다.
```
export const router = createBrowserRouter([
    {
        path: '/',
        element: <RootLayout />,
        // children -> Layout의 Outlet 부분을 뭘로 바꿀지를 설정
        children: [
            {
                index: true,
                element: <IndexPage />
            },
            {
                path: 'blog',
                element: <BlogPage />
            },
            {
                path: 'blog/:postId',
                element: <BlogPostDeatailPage />
            },
            {
                path: 'about',
                element: <AboutPage />
            },
        ]
    },
]);
```
blog 페이지에서 동적 렌더링을 진행하면서 post를 보내주고 있고
```
 return (
    <>
        <div className={styles.blog}>
            <div className={styles.grid}>
                {posts.map(post =>
                    <PostCard key={post.id} post={post} />
                )}
            </div>
        </div>
    </>
);
```
postcard 쪽에서는 props로 post를 받아서 Link에 postId를 넣어줄 수 있다.
```
const PostCard = ({ post }) => {
    return (
        <Link
            to={`/blog/${post.id}`}
            className={styles.cardLink}>
            <div className={styles.card}>
                <h2 className={styles.title}>{post.title}</h2>
                <p className={styles.excerpt}>{post.excerpt}</p>
                <div className={styles.footer}>
                    <span className={styles.date}>{post.date}</span>
                </div>
            </div>
        </Link>
    );
};
```
![alt text](/img/image-15.png)   
postId가 1번인 postcard를 누르면 blog/:postId <- postId에 postcard의 id가 들어가고 디테일페이지가 라우팅된다.

- useParams   
디테일 페이지로 이동하면 해당 post의 정보를 읽어서 렌더링을 진행해야 하는데   
useParams()을 통해 url(/blog/1)의 파라미터 정보를 가져올 수 있다.   
```
const { postId } = useParams
```
useParams는 파라미터가 여러개 인 경우도 있어서 값을 객체로 반환한다.   
url의 경우 쿼리스트링 보다 파라미터가 훨씬 깔끔하고 이해하기 쉽다.   



- 쿼리스트링 읽기: useSearchParams   
blog?category=000&sort=latest <- ? 뒤에 붙는 쿼리스트링은 useSearchParams()로 읽을 수 있다.  

useSearchParams 는 배열을 리턴한다.   
- 0번 인덱스: 쿼리스트링들을 모아놓은 객체
- 1번 인덱스: 쿼리스트링을 생성할 수 있는 함수
```
const[searchParams, setSearchParams] =useSearchParams();
```
```
console.log(searchParams) 하면 아래처럼 쿼리스트링의 개수를 알려준다.
```
![alt text](/img/image-17.png)
![alt text](/img/image-16.png)   

searchParams.get(key) 쿼리스트링 중 특정 key에 해당하는 값을 가져올 수 있다.
```
 const category = searchParams.get('category')
```
![alt text](/img/image-18.png)


| 구분        | 예시              | 특징                                       | 장점/단점                        | 백엔드 요청 방식                             |
| --------- | --------------- | ---------------------------------------- | ---------------------------- | ------------------------------------- |
| **파라미터**  | `/product/1`    | URL 경로의 일부로 포함, `useParams()`로 접근        | 깔끔하고 직관적, RESTful 설계에 적합     | GET/PUT/DELETE 등, `@PathVariable`로 수신 |
| **쿼리스트링** | `/product?id=1` | `?key=value` 형태, `useSearchParams()`로 접근 | 필터링, 정렬 등 옵션 전달에 유리, 길어지면 복잡 | GET 등, `@RequestParam`으로 수신           |


