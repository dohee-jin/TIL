## TIL - 2025.09.02

### 🔍 오늘 배운 내용
- action 함수
- 무한스크롤(복습)

---

#### action 함수   
loader 함수는 CRUD 중 Read 요청 처리를 담당하고   
action 함수는 Create, Update, Delete 요청 처리를 담당할 때 사용한다.   
action 함수도 loader 와 마찬가지로 라우팅 설정으로 이동하여    
api 요청을 할 페이지에 >> **action: 함수** << 을 작성한다.   
```
{
    index: true,
    element: <EventPage />,
    action: async () => {
        console.log('action 함수 실행');
    },
}
```
action 함수도 loader 함수처럼 아웃소싱도 가능하다.   
아웃소싱 한 action 함수도 라우트 설정 파일로 이동하여 임포트하고 action: 에 작성하면 된다.
```
...
{
    index: true,
    element: <EventPage />,
    action: saveAction,
}
...
```

loader 함수는 페이지가 라우팅 되는 순간 실행되지만 action 함수는 페이지가 로딩되고 바로 실행되지 않는다.   

action 함수를 실행하기 위해서는 Form 컴포넌트와 method 속성(필수 속성)을 지정해야 한다.   
method 속성에는 요청하는 Http 메소드 이름을 작성한다.(GET, POST, DELETE, PUT)
```
<Form
    method = 'POST'
    className={styles.form}
    noValidate>
    <p>
        <label htmlFor='title'>Title</label>
        <input
            id='title'
            type='text'
            name='title'
            required
            ref={titleRef}
        />
    </p>
</Form>
```
POST 요청을 보내기 위해서 form에 입력한 값을 action 함수에서 읽어와야 되는데
form 입력 값은 loader와 마찬가지로 react route가 객체 형태{context, params, request}로 제공한다.   
![alt text](/img/image-19.png)   

```
export const eventItemLoader = async (x) => {
    //const response = await fetch(`${DEFAULT_URL}/${eventId}`)
    console.log(x)
    //return response;
}
```
action 함수에서는 request를 가져온다. request안에는 요청 메소드와 formdata 등 여러 정보가 들어있다.   
입력한 정보는 request.formData()로 추출할 수 있다.
```
export const saveAction = async ({ request }) => {

    // form에 입력한 값 가져오기
    // await를 붙여서 비동기적 실행에서 순서를 보장해줌
    const formData = await request.formData();
   
    const payload = {
        title: formData.get('title'),
        desc: formData.get('description'),
        beginDate: formData.get('date'),
        imageUrl: formData.get('image')
    };
    // console.log(payload);

    const response = await fetch('http://localhost:9000/api/events', {
        method: request.method,
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    })

    if(!response.ok) {
        throw new Error('이벤트 생성에 실패했습니다!')
    }

};
```

- useSubmit   
Form 컴포넌트 없이 action 함수를 트리거 하는 것을 낙관적 업데이트라고 부르고
useSubmit() 훅을 사용하여 action 함수를 실행시킨다.    
```
const submit = useSubmit();

const handleRemove = e => {
    // 낙관적 업데이트
    submit(null, {method:'DELETE'});
};

return (
    <>
        <button onClick={handleRemove}>Delete</button>
    </>
)
```
- redirect   
action, loader 함수 내부에서 리다이렉트를 하기 위해 사용.   
useNavigate 와 같은 훅들은 컴포넌트 아래에서만 사용할 수 있다.
```
return redirect(`/~~`) 
```
---

#### 무한스크롤(복습)
- 백엔드   
먼저 페이징 구현에서 사용되는 offeset, limit을 사용하기 위해 QueryDsl 의존성을 주입하고 설정 파일을 만들었다.   

build.gradle에 QueryDsl 의존성 추가
```
dependencies {
    ...
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
}
```
config 폴더에 QueryDslConfig 파일 추가  
```
@Configuration
public class QueryDslConfig {

    @PersistenceContext // JPA에서 주입
    private EntityManager em;

    @Bean
    public JPAQueryFactory factory() {
        return new JPAQueryFactory(em);
    }
}
```
기존에 배웠던 페이지 처리는 Page 객체를 사용했지만, 이번에는 무한 스크롤 구현을 위해 Slice 객체를 사용했다. Slice는 Page와 달리 전체 페이지 수나 전체 데이터 수를 계산하지 않고, 단지 다음 페이지의 존재 여부만 확인하면 된다.    

무한 스크롤은 다음 데이터를 이어서 불러오는 방식으로 기존 Page 객체에서 필요하던 전체 페이지 수 처리에 대한 쿼리가 필요없으며
```
--- Slice에서는 필요없음

Long total = factory
    .select(meetingParticipant.count())
    .from(meetingParticipant)
    .where(meetingParticipant.participant.id.eq(id))
    .fetchOne(); 
```
hasNext로 다음 데이터의 여부를 판단하여 다음 요청을 보내기 때문에   
무한스크롤에서는 Slice 객체 사용이 성능과 코드 작성 면에서 더 효율적인 방법이다.   

무한 스크롤에서도 서버에 저장된 데이터의 끝을 확인해서 페이징을 종료한다.

원래 요청받아올 데이터보다 한 개 더 조회하여 받아올 데이터(ex) 5개) 보다    
서버에서 조회해온 데이터(+ 1개 더 요청)의 크기가 크면 계속 페이징 처리를 진행하고   
조회해온 데이터의 크기가 작다면 저장된 데이터의 끝임을 판단하고 페이징을 종료한다.
Repository
```
public Slice<Event> findEvents(Pageable pageable) {

    // 목록 조회
    List<Event> eventList = factory
            .selectFrom(event)
            .orderBy(event.createdAt.desc())
            .offset(pageable.getOffset()) // 몇개를 건너뛸지
            .limit(pageable.getPageSize() + 1) // 몇개를 조회할지
            .fetch();

    // 추가 데이터가 있는지 확인할 변수
    boolean hasNext = false;
    if(eventList.size() > pageable.getPageSize()){
        hasNext = true;

        // 실제로는 5개만 리턴해야 함, 6번째 데이터는 삭제
        eventList.remove(eventList.size() - 1);
    }

    return new SliceImpl<>(eventList, pageable, hasNext);
}
```
Service
```
@Transactional(readOnly = true)
public Map<String, Object> getEvents(int pageNo) {

    Slice<Event> eventSlice = eventRepository.findEvents(PageRequest.of(pageNo-1, 4));

    List<EventResponse> events = eventSlice.getContent()
            .stream()
            .map(EventResponse::from)
            .collect(Collectors.toList());

    return Map.of(
            "hasNext", eventSlice.hasNext(),
            "eventList", events
    );
}
```
컨트롤러에서도 Slice 객체는 Pageable 전체를 받을 필요 없이 현재 페이지 번호와 사이즈만 받으면 충분하므로 코드가 훨씬 간결해진다.    
Page 객체를 사용할 때는 Pageable을 통해 페이지 번호, 사이즈, 정렬까지 모두 받아야 하고,    
결과도 전체 페이지 수나 총 데이터 수를 포함한 Page 객체로 반환해야 하지만, Slice를 사용하면    
다음 데이터 존재 여부만 판단하면 되므로 요청과 응답 모두 간단해진다.
```
--- Page 객체
@GetMapping("/meetings")
public ResponseEntity<?> getMyMeetings(
        @AuthenticationPrincipal String email,
        @PageableDefault(page = 0, size = 3, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable
) {
    Page<MeetingInfoDto> response = myPageService.getMyMeetings(email, pageable);
    return ResponseEntity.ok(ApiResponse.success("마이페이지 나의 참여 모임 정보 조회를 성공했습니다.", response));
}
```
```
--- Slice 객체
@GetMapping
public ResponseEntity<?> getList(
        @RequestParam(defaultValue = "1") int page
) {
    Map<String, Object> events = eventService.getEvents(page);
    return ResponseEntity.ok().body(events);
}
```

- 프론트엔드
    - 서버 데이터 조회   
    이벤트 페이지 라우팅 시 실행되던 조회 api 요청은 무한스크롤 구현을 위해 라우터 설정에서 제거 한다.
    ```
    {
        index: true,
        element: <EventPage />,
        // 무한스크롤사용을 위해 삭제함
    },
    ```
    다시 EventPage로 이동하여 useEffect를 사용해서 조회 요청을 보내도록 변경했다.
    페이지가 무한스크롤되면서 변경되니까 currentPage라는 이름으로 상태 관리를 하도록 작성했다.   
    
    이벤트 리스트도 페이지 요청이 반복되면서 리렌더링이 되어야 하기 때문에 useState로 상태관리를 하도록 변경했다.

    백엔드로부터 eventList를 받아올 때 hasNext 도 받아오고 있다. 이 hasNext도   
    상태 관리 하여 isFinish가 true면, 더 이상 가져올 데이터가 없으면 조회 요청을 하지 않도록 로직을 작성했다.   
    서버에서 받아온 hasNext는 다음 데이터가 있으면 true를 반환한다.   

    hasNext = true -> isFinish(!hasNext) = false    
    hasNext = false -> isFinish(!hasNext) = true, 더 이상 조회 X
    ```
    // 현재 페이지번호를 상태로 관리
    const[currentPage, setCurrentPage] = useState(1);

    // 이벤트 리스트 상태 관리
    const[eventList, setEventList] = useState([]);

    // 더 이상 가져올 데이터가 있는지 여부
    const[isFinish, setIsFinish] = useState(false);

    const fetchEvents = async () => {

        if(isFinish) return;

        const response = await fetch(`http://localhost:9000/api/events?page=${currentPage}`);
        const {hasNext, eventList: events} = await response.json();

        // 기존 event에 새롭게 가져온 event 들을 붙여서 렌더링 진행
        setEventList(prev => [...prev, ...events]);
        
        // 페이지번호 갱신
        setCurrentPage(prev => prev + 1);
        setIsFinish(!hasNext);

        console.log(currentPage)
    };
    ```
    currentPage가 변경될 때마다 fetchEvent가 실행되어야 하기 때문에 useEffect 의존성 배열에 변경을 감지할 대상인 currentPage를 넣어준다.
    ```
    useEffect(() => {
        fetchEvents();
    } ,[currentPage])
    ```

    - 옵저버로 무한스크롤 구현  
    옵저버는 IntersectionOberver 객체로 생성하고 callback 함수 안에 내용을 작성한다.   
    옵저버는 두 개의 파라미터가 필요하며 첫번째 인자로는 callback 함수로 받고   
    두번째 인자는 option 객체를 받는다.   
      
    callback 함수의 파라미터는 감시대상 배열인 entries를 넣어준다
    ```
    const observer = new IntersectionObserver((entries) => {

    }, options)
    ```
    entries 배열의 각 감시대상 entry는 intersection 이라는 상태 정보를 가진다.   
    .isIntersecting 으로 감시대상이 뷰포트 안에 들어왔는지 확인 가능핟.
    ```
    if(entries[0].isIntersecting) {
        // 요소가 화면에 들어왔을 때 실행할 코드 작성
    }
    ```
    
    옵저버로 무한스크롤을 구현하기 위해 먼저 감시 대상을 설정해야 한다.  
    useEffect 안에서 옵저버를 생성하고 EventList 아래에 div 를 하나 배치하여    
    옵저버의 감시대상으로 설정했다.  

    div 태그를 감시하기 위해서 useRef로 div 태그를 가져왔다.   
    무한 스크롤 내부에도 isFinish 조건을 배치하여 isFinish가 true(가져올 데이터 없음)면   
    무한스크롤도 동작하지 않도록 로직을 작성했다.
    ```
    const observerRef = useRef();

    useEffect(() => {

        // 무한 스크롤을 위한 옵저버를 생성
        const observer = new IntersectionObserver((entries) => {

            if(isFinish) return;

            if(entries[0].isIntersecting) {
                // console.log('감시대상 발견!');
                fetchEvents();
            }
        }, {
            // 관찰하고 있는 대상의 높이가 50% 정도 보일 때 감지 실행
            threshold: 0.5
        })

        // 감시대상 설정
        if(observerRef.current){
            observer.observe(observerRef.current);
        }

        return () => observer.disconnect();

    }, [currentPage])

    return (
        <div>
            <ul>
                <EventList eventList={eventList}/>
                {/*무한스크롤 옵저버를 위한 감시대상 태그*/}
                <div style={{height: 300, background: 'yellow'}} ref={observerRef}>
                    {/*로딩바, 스켈레톤 풀백 배치*/}
                </div>
            </ul>
        </div>
    )
    ```

    useEffect의 cleanup 함수에서 옵저버를 해제하고 있는데 EventPage 컴포넌트가 화면에서 사라질 때 감시를 해제한다.
    현재 코드에서는 isFinish로 fetch 요청을 제어하고 있어 true면 더 이상 데이터 요청을 하고 있지는 않지만 옵저버 감시는 계속되고 있는 상황이다.
    ```
    return () => observer.disconnect();
    ```

    - 스켈레톤 컴포넌트 배치

---

### 🚨 트러블슈팅
#### 🛠️ 문제와 원인
- 문제: 백엔드 @PathVariable {/id} eventId 다름 
- 원인: 

#### ✅ 해결 방법

---

#### 🛠️ 문제와 원인
- 문제: 상세페이지 단일 조회 시 서버에서 받아온 값이 아닌 html을 리턴
- 원인: fetch URL에 쌍따옴표가 잘못 들어감 ``안에 불필요한 작은따옴포가 들어가 문자열로 인식되어 요청이 잘못 날아가고   
Vite 개발 서버가 404를 처리하면서 index.html을 내려주기 때문에 HTML이 보이는 것임

#### ✅ 해결 방법